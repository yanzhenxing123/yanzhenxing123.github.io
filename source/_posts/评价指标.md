---
title: 推荐系统算法评价指标
top: false
cover: false
toc: true
mathjax: true
date: 2023-05-03 14:43:27
password:
summary:
tags:
- 算法评价
categories:
- 推荐系统
---



我们用一张表格展示推荐系统向用户推荐的列表与用户真实的访问项目,如下：

| 用户 | 真实值 |      推荐列表      | 是否命中 |
| ---- | ------ | :----------------: | -------- |
| A    | 12     | 3,10,15,**12**,17  | 是（1）  |
| B    | 3      |   20,15,18,14,30   | 否（0）  |
| C    | 5      |   2,**5**,7,8,15   | 是（1）  |
| D    | 14     | 56,**14**,25,12,19 | 是（1）  |
| E    | 20     |   21,24,36,54,45   | 否（0）  |

评价指标的来源是根据TKDE-2019中的一篇论文使用的方法：



![image-20230503144653099](http://ksdb-blogimg.oss-cn-beijing.aliyuncs.com/typora/202305/03/144653-233340.png)



### 1. 命中率 HR(Hits Ratio)

意义：关心用户想要的，我有没有推荐到，强调预测的“**准确性**”



<img src="http://ksdb-blogimg.oss-cn-beijing.aliyuncs.com/typora/202305/03/143653-749278.png" alt="image-20230503143652239" style="zoom:67%;" />

参数说明:
N: 用户的总数量
hits(i) = 0 or 1，命中为1，没命中为0



### 2. 归一化折损累计增益（Normalized Discounted Cumulative Gain，NDCG）

意义：关心找到的这些项目，是否放在用户更显眼的位置里，即**强调“顺序性“**



![image-20230306201553376](http://ksdb-blogimg.oss-cn-beijing.aliyuncs.com/typora/202303/06/201555-273453.png)

参数说明：
N: 用户的总数量
pi: 第i个用户的真实访问值在推荐列表的位置，若推荐列表不存在该值，则pi→∞

减函数，所以**越靠前NDCG越大**



### 3. 平均倒数排名(Mean Reciprocal Rank,MRR)

意义：关心找到的这些项目，是否放在用户更显眼的位置里，即**强调“顺序性“**

![image-20230306201938014](http://ksdb-blogimg.oss-cn-beijing.aliyuncs.com/typora/202303/06/201938-981382.png)

参数说明：
N: 用户的总数量
pi: 第i个用户的真实访问值在推荐列表的位置，若推荐列表不存在该值，则pi→∞

减函数，所以**越靠前MRR越大**

MRR和NDCG类似

```python
import math

# 推荐列表
R = [[3, 10, 15, 12, 17], [20, 15, 18, 14, 30], [2, 5, 7, 8, 15], [56, 14, 25, 12, 19], [21,24,36,54,45]]
# 用户访问列表
T=[[12],[3],[5],[14],[20]]


def indicators_5(rankedList, testList):
    Hits_i = 0
    Len_R = 0
    Len_T = len(testList)
    MRR_i = 0
    HR_i = 0
    NDCG_i = 0
    for i in range(len(rankedList)):
        for j in range(len(rankedList[i])):
            if testList[i][0]==rankedList[i][j]:
                Hits_i+=1
                HR_i+=1
                # 注意j的取值从0开始
                MRR_i+=1/(j+1)   
                NDCG_i+=1/(math.log2(1+j+1))
                break
    HR_i/=Len_T
    MRR_i/=Len_T
    NDCG_i/=Len_T
    print(Hits_i)
    print(f'HR@5={HR_i}')
    print(f'MRR@5={MRR_i}')
    print(f'NDCG@5={NDCG_i}')



if __name__ == '__main__':
    indicators_5(R, T)
```